% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wapply.R
\name{wapply}
\alias{wapply}
\title{Apply a function to windows of the data}
\usage{
wapply(x, wsize, FUN)
}
\arguments{
\item{x}{Data; vector, matrix, or data frame.}

\item{wsize}{Window size, in number of indices.}

\item{FUN}{Function to apply to each window of data. If applying to a vector \code{FUN} can be a simple function like \code{median} (see example); otherwise it should be defined as having one argument, \code{x}, indicating data.}
}
\description{
Iteratively applies function \code{FUN} to subsets of the data defined by a 
sliding window centered on each index in turn.
}
\details{
For each index, the indices \code{current_index - floor(wsize/2)} to 
\code{current_index - floor(wsize/2)} are taken and the function \code{FUN}
is applied to that subset of data. At the edges, where \code{floor(wsize/2)}
would extend beyond the data, the out-of-range indices are ignored. This means 
that at the edges of the data the window size is effectively around half of 
the full window size.

The values returned from the function are simplified into a vector if possible,
otherwise to a matrix, and as a last resort as a list.

As this method iterates over each index (in a matrix or data frame, each row),
it is of the utmost importance that the data is sorted appropriately (which is
equally applicable for similar functions such as \code{runmed()}).
}
\examples{

d <- rnorm(10)
window_median_runmed <- runmed(d,3) # from `stats` package
window_median_wapply <- wapply(d, 3, median) # identical except at edges

d <- data.frame(x = rnorm(400))
d$y <- d$x + rnorm(400)*(sin(seq(0,12,length = 400)+1))

window_correl <- wapply(d, 40, function(x){cor(x[,'x'],x[,'y'])})

plot(window_correl)

}
